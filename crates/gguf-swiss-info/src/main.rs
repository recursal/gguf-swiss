use std::fs::File;

use anyhow::{bail, Context, Error};
use clap::Parser;
use gguf_swiss::Header;

fn main() -> Result<(), Error> {
    let args = Args::parse();

    let mut file = File::open(args.path)?;

    let header = gguf_swiss::read_header(&mut file).context("failed to read gguf header")?;

    let architecture = header.metadata.get("general.architecture");
    let Some(architecture) = architecture else {
        bail!("required key \"general.architecture\" missing from model")
    };

    // Extract important information KVs
    let name = get_metadata(&header, "general.name", "");
    let author = get_metadata(&header, "general.author", "");
    let url = get_metadata(&header, "general.url", "");
    let description = get_metadata(&header, "general.description", "");
    let license = get_metadata(&header, "general.license", "");

    // Print information
    println!("# {} - GGUF Model Information", name);
    println!("Name: {}", name);
    println!("Author: {}", author);
    println!("URL: {}", url);
    println!("Description: {}", description);
    println!("License: {}", license);
    println!("Architecture: {}", architecture);
    println!("GGUF Version: {}", 3);
    println!("Metadata KV Count: {}", header.metadata.len());
    println!("Tensor Count: {}", header.tensors.len());

    println!("\n## Metadata");
    for (key, value) in header.metadata {
        println!("`{}`: {}", key, value);
    }

    println!("\n## Tensors");
    let mut tensors: Vec<_> = header.tensors.iter().collect();
    tensors.sort_by_key(|(k, _)| k.as_str());
    for (key, value) in tensors {
        println!(
            "`{}`: `{{type: {:?}, dimensions: {}, offset: {}}}`",
            key, value.tensor_type, value.dimensions, value.offset
        );
    }

    // Generation metadata for debugging
    println!("\n## GGUF Swiss");
    println!(
        "Model information generated by {} {}.",
        PKG_NAME, PKG_VERSION
    );

    Ok(())
}

/// GGUF Swiss Army Knife, model information printer utility.
#[derive(Parser, Debug)]
#[command(version, about)]
struct Args {
    /// Path to the model to read.
    path: String,
}

const PKG_NAME: &str = env!("CARGO_PKG_NAME");

const PKG_VERSION: &str = env!("CARGO_PKG_VERSION");

fn get_metadata(header: &Header, key: &str, default: &str) -> String {
    header
        .metadata
        .get(key)
        .cloned()
        .unwrap_or(default.to_string())
}
