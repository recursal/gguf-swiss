use std::fs::File;

use anyhow::{bail, Context, Error};
use clap::Parser;
use gguf_swiss::{Header, MetadataValue};

fn main() -> Result<(), Error> {
    let args = Args::parse();

    let mut file = File::open(args.path)?;

    let header = gguf_swiss::read_header(&mut file).context("failed to read gguf header")?;

    let architecture = header.find_metadata("general.architecture");
    let Some(MetadataValue::String(architecture)) = architecture else {
        bail!("required key \"general.architecture\" missing from model")
    };
    let architecture = String::from_utf8(architecture.clone())?;

    // Extract important information KVs
    let name = get_metadata(&header, "general.name", "")?;
    let author = get_metadata(&header, "general.author", "")?;
    let url = get_metadata(&header, "general.url", "")?;
    let description = get_metadata(&header, "general.description", "")?;
    let license = get_metadata(&header, "general.license", "")?;

    // Print information
    println!("# {} - GGUF Model Information", name);
    println!("Name: {}", name);
    println!("Author: {}", author);
    println!("URL: {}", url);
    println!("Description: {}", description);
    println!("License: {}", license);
    println!("Architecture: {}", architecture);
    println!("GGUF Version: {}", 3);
    println!("Metadata KV Count: {}", header.metadata.len());
    println!("Tensor Count: {}", header.tensors.len());

    println!("\n## Metadata");
    for (key, value) in header.metadata {
        let value = format_value(&value);
        println!("`{}`: {}", key, value);
    }

    println!("\n## Tensors");
    let mut tensors: Vec<_> = header.tensors.iter().collect();
    tensors.sort_by_key(|v| v.name.as_str());
    for tensor in tensors {
        println!(
            "`{}`: `{{type: {:?}, dimensions: {}, offset: {}}}`",
            tensor.name, tensor.tensor_type, tensor.dimensions, tensor.offset
        );
    }

    // Generation metadata for debugging
    println!("\n## GGUF Swiss");
    println!(
        "Model information generated by {} {}.",
        PKG_NAME, PKG_VERSION
    );

    Ok(())
}

/// GGUF Swiss Army Knife, model information reader utility.
#[derive(Parser, Debug)]
#[command(version, about)]
struct Args {
    /// Path to the model to read.
    path: String,
}

const PKG_NAME: &str = env!("CARGO_PKG_NAME");

const PKG_VERSION: &str = env!("CARGO_PKG_VERSION");

fn get_metadata(header: &Header, key: &str, default: &str) -> Result<String, Error> {
    let Some(value) = header.find_metadata(key) else {
        return Ok(default.to_string());
    };

    let MetadataValue::String(value) = value else {
        return Ok(default.to_string());
    };

    let value = String::from_utf8(value.clone())?;
    Ok(value)
}

fn format_value(value: &MetadataValue) -> String {
    match value {
        MetadataValue::UInt8(value) => value.to_string(),
        MetadataValue::Int8(value) => value.to_string(),
        MetadataValue::UInt16(value) => value.to_string(),
        MetadataValue::Int16(value) => value.to_string(),
        MetadataValue::UInt32(value) => value.to_string(),
        MetadataValue::Int32(value) => value.to_string(),
        MetadataValue::Float32(value) => value.to_string(),
        MetadataValue::Bool(value) => value.to_string(),
        MetadataValue::String(value) => format!("{:?}", value),
        MetadataValue::Array(value) => format!("[{:?}; {}]", value.ty(), value.len()),
        MetadataValue::UInt64(value) => value.to_string(),
        MetadataValue::Int64(value) => value.to_string(),
        MetadataValue::Float64(value) => value.to_string(),
    }
}
